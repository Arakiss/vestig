# Features

Deep dive into Vestig's core features.

## Structured Output

Vestig outputs logs as JSON by default in production, making them easy to parse and analyze with tools like Datadog, Splunk, or CloudWatch.

```typescript
import { log } from 'vestig'

log.info('User action', { userId: '123', action: 'click' })
```

Output:
```json
{
  "level": "info",
  "message": "User action",
  "metadata": {
    "userId": "123",
    "action": "click"
  },
  "timestamp": "2024-01-15T10:30:00.000Z",
  "runtime": "bun"
}
```

## Sanitization

Vestig automatically detects and sanitizes sensitive data to prevent accidental PII exposure in logs.

### Default Sensitive Fields

These field names are automatically redacted:

- `password`, `pass`, `pwd`
- `token`, `access_token`, `refresh_token`
- `api_key`, `apikey`, `secret`
- `authorization`, `bearer`, `auth`
- `session_id`, `sessionid`, `cookie`
- `credit_card`, `creditcard`, `cvv`
- `ssn`, `social_security`

### Pattern-Based Detection

Vestig also detects patterns in values:

```typescript
log.info('User data', {
  email: 'john@example.com',     // → jo***@example.com
  card: '4111 1111 1111 1111',   // → ****1111
  token: 'eyJhbGciOiJIUzI1NiI...' // → [JWT_REDACTED]
})
```

### Custom Sensitive Fields

Add your own sensitive field patterns:

```typescript
const logger = createLogger({
  sanitize: true,
  sanitizeFields: ['mySecret', 'internalKey']
})

logger.info('Data', { mySecret: 'value' })
// → { mySecret: '[REDACTED]' }
```

## Context Propagation

Automatically correlate logs across your entire request lifecycle using AsyncLocalStorage.

### Setting Up Context

```typescript
import { withContext, createCorrelationContext, log } from 'vestig'

// In your middleware
app.use((req, res, next) => {
  const ctx = createCorrelationContext()
  // ctx = { requestId, traceId, spanId }

  withContext(ctx, () => {
    log.info('Request started')
    next()
  })
})
```

### Accessing Context

All logs within the context automatically include correlation IDs:

```json
{
  "level": "info",
  "message": "Request started",
  "context": {
    "requestId": "550e8400-e29b-41d4-a716-446655440000",
    "traceId": "0af7651916cd43dd8448eb211c80319c",
    "spanId": "b7ad6b7169203331"
  }
}
```

### Async Support

Context is preserved across async operations:

```typescript
withContextAsync({ requestId: 'req-123' }, async () => {
  await db.query('SELECT ...')
  log.info('Query completed') // Still has requestId
})
```

## Child Loggers

Create namespaced loggers for different parts of your application:

```typescript
const logger = createLogger({ level: 'info' })

// Create child loggers
const dbLogger = logger.child('database')
const apiLogger = logger.child('api')
const authLogger = logger.child('auth')

dbLogger.info('Query executed')
// → namespace: "database"

apiLogger.info('Request received')
// → namespace: "api"
```

### Chained Namespaces

Child loggers can be nested:

```typescript
const appLogger = logger.child('app')
const userService = appLogger.child('user-service')

userService.info('User created')
// → namespace: "app:user-service"
```

### Overriding Config

Child loggers can override parent configuration:

```typescript
const debugLogger = logger.child('debug', { level: 'trace' })
debugLogger.trace('Very detailed info')
```

## Error Handling

Vestig serializes errors with full stack traces:

```typescript
try {
  await riskyOperation()
} catch (error) {
  log.error('Operation failed', error)
}
```

Output includes:
```json
{
  "level": "error",
  "message": "Operation failed",
  "error": {
    "name": "TypeError",
    "message": "Cannot read property 'x' of undefined",
    "stack": "TypeError: Cannot read property..."
  }
}
```

## Runtime Detection

Vestig automatically detects the runtime environment:

```typescript
import { RUNTIME, CAPABILITIES } from 'vestig'

console.log(RUNTIME)
// → 'node' | 'bun' | 'deno' | 'edge' | 'browser'

console.log(CAPABILITIES)
// → { hasAsyncLocalStorage: true, hasConsole: true, ... }
```
